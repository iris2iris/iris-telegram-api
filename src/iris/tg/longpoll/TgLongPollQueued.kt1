package iris.tg.longpoll

import iris.tg.TgReadWriteUpdateBuffer
import iris.tg.TgReadWriteBufferDefault
import iris.tg.api.TgApiObject
import iris.tg.api.items.Update
import iris.tg.api.response.TgResponse
import iris.tg.processors.TgUpdateMultibotProcessor
import iris.tg.processors.TgUpdateProcessor
import iris.tg.processors.TgUpdateProcessor2Multibot
import iris.tg.processors.pack.TgEventPackHandler
import iris.tg.processors.pack.TgEventPackHandlerBasicTypes
import iris.tg.processors.pack.TgUpdateProcessorPack
import iris.tg.processors.single.TgEventSingleHandler
import iris.tg.processors.single.TgUpdateProcessorSingle
import iris.tg.webhook.BotSource

/**
 * @created 02.11.2020
 * @author [Ivan Ivanov](https://t.me/irisism)
 */
open class TgLongPollQueued(
	api: TgApiObject,
	private val updateProcessor: TgUpdateProcessor<Update>,
	buffer: TgReadWriteUpdateBuffer<Update>? = null,
	exceptionHandler: GetUpdateExceptionHandler<TgResponse>? = null
) : Runnable {

	constructor(api: TgApiObject, handler: TgEventSingleHandler, buffer: TgReadWriteUpdateBuffer<Update>? = null, exceptionHandler: GetUpdateExceptionHandler<TgResponse>? = null)
			: this(api, TgUpdateProcessorSingle(handler), buffer, exceptionHandler)

	constructor(api: TgApiObject, handler: TgEventPackHandlerBasicTypes, buffer: TgReadWriteUpdateBuffer<Update>? = null, exceptionHandler: GetUpdateExceptionHandler<TgResponse>? = null)
			: this(api, TgUpdateProcessorPack(handler), buffer, exceptionHandler)

	constructor(api: TgApiObject, botData: BotSource.BotData, handler: TgUpdateMultibotProcessor<Update>, buffer: TgReadWriteUpdateBuffer<Update>? = null, exceptionHandler: GetUpdateExceptionHandler<TgResponse>? = null)
			: this(api, TgUpdateProcessor2Multibot<Update>(botData, handler), buffer, exceptionHandler)

	private val buffer = buffer ?: TgReadWriteBufferDefault(1000)
	private var working = true
	private val polling = TgLongPoll(api, UP(this.buffer), exceptionHandler)

	override fun run() {
		polling.startPolling()
		working = true
		val thisThread = thread ?: Thread.currentThread()
		val buffer = buffer
		val updateProcessor = updateProcessor
		while (!thisThread.isInterrupted && working) {
			val items = buffer.readAll()
			if (items.isEmpty()) continue
			updateProcessor.processUpdates(items)
		}
	}

	private var thread: Thread? = null

	fun startPolling() {
		stop()
		thread = Thread(this).also { it.start() }
	}

	fun stop() {
		polling.stop()
		working = false
		thread?.interrupt()
	}

	private class UP(private val buffer: TgReadWriteUpdateBuffer<Update>) : TgUpdateProcessor<Update> {
		override fun processUpdates(updates: List<Update>) {
			buffer.write(updates)
		}

		override fun processUpdate(update: Update) {
			buffer.write(update)
		}
	}
}